# 计算机网络

## DNS
#### 是tcp还是udp的服务？
运行在udp上端口号为53的服务。以应用层协议实现。

#### TLD服务器
顶级域名服务器。com、edu...国家的顶级域名：cn、uk、jp...
network solutions 公司负责com tld服务器
educause公司负责edu tld服务器

#### dns记录的类型
DNS（Domain Name System）记录的Type字段指定了DNS资源记录的类型，它标识了记录的含义和用途。不同的Type值对应不同的记录类型，用于表示不同的信息，如域名到IP地址的映射、邮件服务器信息等。以下是常见的DNS记录类型及其含义：

1. **A记录（Address Record）**： 将域名映射到IPv4地址。
    
2. **AAAA记录（IPv6 Address Record）**： 将域名映射到IPv6地址。
    
3. **CNAME记录（Canonical Name Record）**： 定义域名的别名，将一个域名指向另一个域名。
    
4. **MX记录（Mail Exchange Record）**： 指定邮件服务器，用于电子邮件的路由。

#### 本地名字服务器
本地名称服务器（Local Name Server），也称为递归名称服务器（Recursive Name Server），是位于本地网络或ISP（互联网服务提供商）网络中的DNS服务器。它的主要功能是处理客户端设备（如计算机、手机、路由器等）发起的域名解析请求，为这些设备提供域名解析服务。

本地名称服务器的工作流程如下：

1. **接收请求**： 当客户端设备尝试访问一个域名时，它会向本地名称服务器发送域名解析请求。
    
2. **查询缓存**： 本地名称服务器首先检查自己的缓存，看是否已经解析过这个域名。如果有，它会直接返回缓存中的IP地址，从而加快解析速度。
    
3. **递归查询**： 如果缓存中没有该域名的记录，本地名称服务器会执行递归查询的过程。它会从根DNS服务器开始，向下逐级查询，直到获取到所需的IP地址。这个过程中，本地名称服务器会依次联系根DNS服务器、顶级域名服务器、权威域名服务器，直到找到目标域名的IP地址。
    
4. **返回结果**： 一旦本地名称服务器获得了域名的IP地址，它会将结果返回给客户端设备，并在自己的缓存中存储一份，以备将来的查询使用。


#### 根DNS服务器、顶级域名服务器、权威域名服务器分别存放哪些内容
1. 根DNS服务器（Root DNS Server）是互联网域名系统（DNS）的最高层级服务器。它存放着顶级域名服务器的信息，其中包括全球顶级域（gTLDs）和国家顶级域（ccTLDs）的域名服务器的地址。根DNS服务器存放的内容是一系列顶级域名服务器的IP地址，用于解析顶级域名的域名服务器地址。

2. 顶级域名服务器（Top-Level Domain DNS Server）是负责管理特定顶级域名的域名服务器，例如".com"、".org"、".net"等。每个顶级域名服务器存放着该顶级域名下的权威域名服务器的地址。顶级域名服务器存放的内容是该顶级域名下的权威域名服务器的IP地址，用于解析该顶级域名下的域名。

3. 权威域名服务器（Authoritative DNS Server）是负责存储和提供特定域名区域信息的域名服务器。它存放着特定域名的DNS记录，包括主机记录（如A记录、AAAA记录）、邮件交换记录（MX记录）、别名记录（CNAME记录）等。权威域名服务器存放的内容是特定域名的DNS记录，用于解析该域名下的具体资源。

**综上所述，根DNS服务器存放顶级域名服务器的地址，顶级域名服务器存放权威域名服务器的地址，而权威域名服务器存放特定域名的DNS记录。这三者共同构成了互联网域名系统的层级结构，用于解析域名到对应的IP地址或其他资源。**

## HTTP
#### Https的具体加密过程

HTTPS 的加密过程主要基于 SSL（Secure Sockets Layer）或其继任者 TLS（Transport Layer Security）协议。以下是 HTTPS 加密过程的主要步骤，包括密钥交换的实现流程：

1. **客户端发送请求：** 客户端（浏览器）发送一个 HTTPS 请求给服务器，例如访问一个安全的网站。
2. **服务器发送证书：** 服务器会将其 SSL/TLS 证书发送给客户端。证书包含服务器的公钥、证书的颁发者、证书的有效期等信息。
3. **客户端验证证书：** 客户端会验证服务器的证书是否有效，以确保正在与合法的服务器通信。验证包括检查证书是否由可信的证书颁发机构签发（CA 颁发的证书）以及证书是否没有过期。
4. **生成临时密钥：** 客户端会生成一个临时的随机密钥，用于本次会话的加密和解密。这个密钥被称为 "Pre-Master Secret"。
5. **使用公钥加密：** 客户端将 Pre-Master Secret 使用服务器的公钥进行加密，然后将加密后的 Pre-Master Secret 发送给服务器。
6. **服务器解密：** 服务器使用自己的私钥解密客户端发送的 Pre-Master Secret，得到了相同的临时密钥。
7. **共享密钥生成：** 客户端和服务器都有了相同的临时密钥（Pre-Master Secret），它们会使用这个密钥生成 "Master Secret"。
8. **握手完成：** 客户端和服务器现在都有了 Master Secret，它们用它来加密和解密数据。握手阶段完成，安全连接建立。
9. **数据传输：** 客户端和服务器使用 Master Secret 进行对称加密，对传输的数据进行加密和解密。这样，数据在传输过程中变得不可读。

总结来说，HTTPS 加密的核心是使用非对称加密来安全地交换对称加密所需的密钥。服务器的公钥用于加密临时密钥，而服务器的私钥用于解密。在握手完成后，客户端和服务器使用共享的对称密钥来加密和解密实际的数据传输。这样，即使在公共网络上传输的数据也能够保持机密性和完整性。

#### HTTP1.0和HTTP1.1的区别

- **连接方式** : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。
- **状态响应码** : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
- **缓存机制** : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- **带宽**：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host 头（Host Header）处理** :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

---

## HTTPS握手过程



1.客户端提交https请求

2.服务器响应客户,并把服务器公钥发给客户端

3.客户端验证公钥的有效性

4.有效后，客户端会生成一个会话密钥(一个随机数)

5.用服务器公钥加密这个会话密钥后，发送给服务器

6.服务器收到公钥加密的密钥后，用私钥解密，获取会话密钥
**公钥加密的消息仅能通过服务端的私钥解密**

7.客户端与服务器利用会话密钥对传输数据进行对称加密通信

![[Pasted image 20230820213949.png]]

![[Pasted image 20230820220627.png]]
### 第一次握手：

四次握手的第一次握手是客户端向服务器发送Client Hello消息，消息以明文的形式传输，里面包括客户端支持的协议版本、加密套件、压缩算法、客户端生成的一个随机数R1、扩展字段等。其中加密套件是四个功能的组合，即：认证算法（Au）、密钥交换算法（KeyExchange）、对称加密算法（Enc）和信息摘要算法，随机数R1则会在后面的密钥生成中使用到。

### 第二次握手：

① 应对客户端发来的Client Hello，服务器将发送Server Hello消息进行响应，该消息以明文的形式传输，相应消息包括确认使用的协议版本、由服务器生成的随机数R2，确认使用的加密套件、确认使用的压缩方法。

② 在发完Server Hello消息后，服务器会马上将自己的Certificate（公钥证书）发送给客户端。

③ Server Key Exchange并非必需选项，只有在选用了DH算法的情况下，服务器需要将DH参数发送给客户端，若选择了RSA算法则不需要发送Server Key Exchange。

④ Certificate Request也并非必须选项，在对于安全性要求较高的场景中，服务器可要对客户端的身份进行认证，因此发起了对客户端公钥证书的请求，一般情况下浏览器都会内置一对独一无二的公私钥。

⑤ 由于第二次握手中包含一些可选选项，因此需要服务器发送一个Server Hello Done的消息，用来通知客户端Server Hello过程结束。

在客户端收到Server Hello Done之后并没有马上进行第三次握手，而是先对服务器传来的证书进行验证，一般会验证证书是否在有效期内，随后根据CRL或者OCSP查询证书是否有效，最后根据证书链从根CA开始验证直到网站证书，以确保证书的真实性。在这个过程中若出现了验证不通过的结果，则抛出相应的错误；若验证通过，就再生成一个随机数Pre-master，并用服务器公钥进行加密，生成PreMaster Key。

### 第三次握手：

① Client Key Exchange就是客户端将PreMaster Key发送给服务器，服务器则会用自己的私钥解密得出Pre-master。到这里客户端和服务器都拥有了三个随机数R1、R2和Pre-master，两边再用相同的算法和这三个随机数生成一个密钥，用于握手结束后传输数据的对称加密。

② Change Cipher Spec是客户端向服务器通知，后面发送的消息都会使用协商出来的密钥进行加密。

③ Encrypted Handshake Message是客户端向服务发送握手数据加密信息，该信息是客户端将前面的握手消息利用协商好的摘要算法生成摘要，再用协商好的密钥对摘要进行加密而的出来的，最后将加密信息发送给服务器，这是客户端发出的第一条加密信息。而服务器也会用协商好的密钥进行解密，若能成功解密则说明协商出来的密钥是一致的。

④ Certificate是在第二次握手的第4步有进行的情况下，即服务器有向客户端请求证书的情况才会有的，这一步是客户端向服务器发送客户端的证书，而服务器收到证书后也会对证书进行相同的验证。

### 第四次握手：

① Change Cipher Spec是服务器向客户端通知，后面发送的消息都会使用协商出来的密钥进行加密。

② Encrypted Handshake Message与第三次握手类似，是服务器发给客户端的用来确定协商的密钥是一致的，也是一条Server Finish消息。

至此TLS四次握手也就完成了，双方已经协商好使用的加密套件和对称密钥，接下来的交互数据都将经过加密后再使用TCP进行传输。

## 传输层

#### TCP段和数据报的格式
TCP段（Segment）和UDP数据报（Datagram）是在传输层使用的数据单元，它们具有不同的格式。以下是它们的格式概述：

**TCP段（Segment）的格式**：

luaCopy code

```lua
-------------------------------------
| 源端口 | 目标端口 | 序列号 | 确认号 |
|-----------------------------------|
| 数据偏移 | 保留 | 控制标志 | 窗口大小 |
|-----------------------------------|
| 校验和 | 紧急指针 | 选项和填充（可选） |
|-----------------------------------|
| 数据（Payload） |
-------------------------------------
```


- **源端口**和**目标端口**：标识发送方和接收方的端口号。
- **序列号**：用于标识发送方发送的数据字节在数据流中的位置。
- **确认号**：表示期望接收方下一个期望收到的字节的序列号。
- **数据偏移**：指示TCP头部长度，以4字节为单位。
- **控制标志**：包括TCP的各种控制信息，如SYN、ACK、FIN等。
- **窗口大小**：接收方可接收的字节数量，用于流量控制。
- **校验和**：用于检测头部和数据的错误。
- **紧急指针**：指示紧急数据的位置。
- **选项和填充**：可选字段，用于配置特定的TCP选项和填充数据。

**UDP数据报（Datagram）的格式**：

markdownCopy code

```lua
-------------------------------------
| 源端口 | 目标端口 | 长度 | 校验和 |
|-----------------------------------|
| 数据（Payload） |
-------------------------------------
```


- **源端口**和**目标端口**：标识发送方和接收方的端口号。
- **长度**：数据报的长度，包括头部和数据。
- **校验和**：用于检测头部和数据的错误。
- **数据（Payload）**：实际要传输的数据部分。

总的来说，TCP段包含了用于控制传输的各种信息，而UDP数据报则相对简单，只包含了必要的头部信息。TCP提供了可靠的、面向连接的传输，UDP则是无连接的、不可靠的传输。应用程序根据其需求选择适合的传输协议和数据格式。



#### tcp两次握手可能发生的问题
**SYN攻击**： 恶意的攻击者可以发送大量的SYN报文给服务器，使服务器不断分配资源，最终耗尽资源，无法处理正常的连接请求。

**半开连接**： 在两次握手的过程中，如果客户端超时重新建立链接，那么就可能会建立两个链接。这样在第二个链接中服务器将一直等待客户端的ACK报文，占用资源。

  
#### 三次握手
TCP的三次握手是建立连接的过程，确保双方都愿意进行通信。以下是三次握手的流程：

1. **客户端向服务器发送SYN报文**： 客户端发起连接时，向服务器发送一个带有SYN标志的TCP报文，同时选择一个初始的随机序列号（Seq）作为起始点。这个报文告诉服务器客户端希望建立连接，并传递初始序列号。
    
    
    `客户端 ----(SYN)----> 服务器 Seq=X`
    
2. **服务器响应，发送SYN-ACK报文**： 服务器接收到客户端的SYN报文后，会回复一个带有SYN和ACK标志的TCP报文。服务器也会选择一个初始的随机序列号（Seq）作为起始点，同时使用客户端发送的序列号加一作为确认号（Ack），告诉客户端服务器接收到了请求并同意建立连接。
    
    
    `客户端 <----(SYN, ACK)---- 服务器 Seq=Y, Ack=X+1`
    
3. **客户端发送ACK报文**： 客户端收到服务器的SYN-ACK报文后，会发送一个带有ACK标志的TCP报文给服务器，确认服务器的确认。客户端会使用服务器发送的序列号加一作为确认号。
    
    
    `客户端 ----(ACK)----> 服务器 Seq=X+1, Ack=Y+1`
    

完成了这三个步骤后，TCP连接就建立起来了。此时客户端和服务器都知道对方愿意进行通信，各自也已经选择好初始序列号，可以开始正常的数据传输。三次握手确保了连接的可靠性，因为每个步骤都需要对方的确认。如果任何一步失败，都会重新尝试建立连接。



#### 四次挥手
TCP的四次挥手是关闭连接的过程，用于确保双方都愿意终止通信。以下是四次挥手的流程：

1. **客户端向服务器发送FIN报文**： 当客户端完成了数据的发送后，它会发送一个带有FIN标志的TCP报文给服务器，表示客户端没有更多数据要发送了，但仍可以接收数据。
    
    `客户端 ----(FIN)----> 服务器 Seq=U`
    
2. **服务器回复ACK报文**： 服务器接收到客户端的FIN报文后，会发送一个带有ACK标志的TCP报文给客户端，确认接收到了FIN报文。

    
    `客户端 <----(ACK)---- 服务器 Ack=U+1`
    
    此时，服务器进入半关闭状态，服务器端仍然可以向客户端发送数据，但客户端不能再向服务器发送数据。
    
3. **服务器向客户端发送FIN报文**： 当服务器完成了数据的发送后，会发送一个带有FIN标志的TCP报文给客户端，表示服务器已经没有数据要发送了。

    
    `客户端 <----(FIN)---- 服务器 Seq=V, Ack=U+1`
    
4. **客户端回复ACK报文**： 客户端接收到服务器的FIN报文后，会发送一个带有ACK标志的TCP报文给服务器，确认接收到了FIN报文。这个ACK报文告诉服务器它可以关闭连接了。
    
    `客户端 ----(ACK)----> 服务器 Ack=V+1`
    


之后客户端进入超时等待阶段，开始计时器定时2\*Rtt或者2\*max segment lifetime，以防服务器没有收到最后一次ack而维持连接。

tcp中的超时重传时间一般为一个RTT多一点，而RTT远小于MSL，所以等待2\*Msl是合适的。

完成了这四个步骤后，TCP连接就被彻底关闭了。四次挥手确保了双方都知道对方愿意终止通信，并且在关闭连接时完成了所有的数据传输和确认。这样可以避免数据的丢失或不完整。

#### 为什么要等待2MSL？

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。有以下两个原因：

- **第一点：保证TCP协议的全双工连接能够可靠关闭**：  
    由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于`CLOESD`状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。
- **第二点：保证这次连接的重复数据段从网络中消失**  
    如果Client端发送最后的ACK直接进入`CLOSED`状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。


#### RTT和MSL谁大
1. **RTT（Round-Trip Time）**： RTT是指从发送数据包到接收到对应的确认（ACK）所经过的时间。它表示了数据从发送端到接收端再回到发送端的时间。RTT的大小会受到网络延迟、拓扑结构、拥塞等多种因素的影响。RTT的范围可能从几毫秒到数百毫秒，甚至更长，具体取决于网络的情况。
    
2. **MSL（Maximum Segment Lifetime）**： MSL是指一个TCP分段（Segment）在网络中最长存活的时间。它是一个TCP连接终止后，等待足够时间以确保所有分段都已经从网络中消失的时间。MSL的标准值是2倍的最大段寿命，最大段寿命通常是在2分钟（120秒）左右，因此MSL大约为4分钟（240秒）。




## TCP

可靠数据传输，流量控制，连接管理，拥塞控制。


#### TCP拥塞控制
TCP拥塞控制主要包括以下几个关键机制：

1. **慢启动（Slow Start）**： 慢启动是TCP连接刚开始时的阶段，在这个阶段，发送方逐渐增加发送数据的速率，以便测试网络的负载情况。发送方会将拥塞窗口大小从一个小值开始，然后每当收到一个确认时，窗口大小就会加倍，直到达到一个阈值。
    
2. **拥塞避免（Congestion Avoidance）**： 一旦达到阈值，TCP进入拥塞避免阶段。在这个阶段，窗口大小不再加倍，而是以较小的增量逐步增加，以避免过快增加导致的拥塞。通常采用加性增大，即每收到一个确认，窗口大小增加一个固定的值。
    
3. **快速重传和快速恢复**： 如果发送方连续收到三个重复的确认，它会认为网络中出现了丢包，进入快速重传和快速恢复状态。此时，发送方会重传丢失的报文段，并将窗口大小减半，以减少拥塞。当出现超时，则直接认为发生拥塞，窗口大小直接减为1mss，之后倍增到原来二分之一再一次加一。
4. MSS代表"Maximum Segment Size"


#### 输入网址到网页显示的过程

这个过程可以分为六步

- 浏览器通过域名找出其IP地址（DNS解析）
- 浏览器和服务器建立连接（TCP/TP三次握手）
- 浏览器向服务器发送HTTP请求
- 服务器接受到请求并返回HTTP响应
- 浏览器解析渲染页面
- 断开连接（四次挥手）

##### 1  浏览器通过域名找出其IP地址（DNS解析）

- 客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。（浏览器缓存→系统缓存→路由器缓存→ISP DNS缓存→从根域名服务器递归搜索）

##### 5 浏览器解析渲染页面

- 浏览器根据响应开始显示页面
- 浏览器首先解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。