

## 分布式系统的CAP

CAP 是指分布式系统中的三个核心概念：一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）。CAP 定理指出，在分布式系统设计中，不可能同时满足这三个概念的完全一致。

下面是对 CAP 三个概念的简要介绍：

1. 一致性（Consistency）：一致性是指在分布式系统中的所有节点对外呈现一致的数据状态。换句话说，当一个节点修改了数据后，其他节点应该能够立即看到最新的数据。一致性要求系统的更新操作是原子的、顺序一致的，并且遵循事务的隔离性等属性。
    
2. 可用性（Availability）：可用性是指分布式系统在面对节点故障或网络分区等异常情况时，仍然能够保证对外提供服务并处理请求。可用性要求系统能够在合理的时间内给出响应，不会因为节点故障而导致整个系统不可用。
    
3. 分区容错性（Partition Tolerance）：分区容错性是指分布式系统在面对网络分区（节点之间无法相互通信）时，仍能够继续运行并保持数据一致性或可用性。分区容错性要求系统能够将节点划分为多个分区，并在分区之间进行通信，即使分区间的通信发生故障或延迟，系统仍能正常运行。
    

根据 CAP 定理，分布式系统在面对网络分区时，必须在一致性和可用性之间做出选择。具体来说，当发生网络分区时，系统可以选择保证一致性（牺牲可用性）或保证可用性（牺牲一致性），但无法同时满足二者。


## HTTP状态码
**xx - Informational（信息响应）：**

- 100 Continue：继续，表示服务器已经接收了请求的一部分，客户端应继续发送其余部分。

**2xx - Successful（成功响应）：**

- 200 OK：请求成功。
- 201 Created：已创建，成功请求并创建了资源。
- 204 No Content：无内容，请求成功，但没有返回内容。

**3xx - Redirection（重定向响应）：**

- 300 Multiple Choices：多种选择，请求的资源有多种表示形式。
- 301 Moved Permanently：永久重定向，请求的资源已永久移动到新的位置。
- 302 Found（或者 307 Temporary Redirect）：临时重定向，请求的资源暂时移动到新的位置。
- 304 Not Modified：未修改，客户端缓存的资源仍有效，可以直接使用。

**4xx - Client Error（客户端错误响应）：**

- 400 Bad Request：请求无效或不正确。
- 401 Unauthorized：未授权，需要身份验证。
- 403 Forbidden：禁止访问，服务器理解请求，但拒绝授权。
- 404 Not Found：未找到，请求的资源不存在。
- 405 Method Not Allowed：方法不允许，请求方法不被允许。
- 406 Not Acceptable：不可接受，客户端请求的格式不被服务器支持。
- 409 Conflict：冲突，请求与当前资源状态冲突。
- 410 Gone：已经消失，请求的资源不存在且不再可用。
- 415 Unsupported Media Type：不支持的媒体类型，请求的内容类型不被支持。
- 429 Too Many Requests：请求过多，客户端发送的请求过多。

**5xx - Server Error（服务器错误响应）：**

- 500 Internal Server Error：服务器内部错误，服务器遇到错误，无法完成请求。
- 501 Not Implemented：未实现，服务器不支持请求的功能。
- 502 Bad Gateway：错误网关，服务器充当网关或代理，从上游服务器收到无效响应。
- 503 Service Unavailable：服务不可用，服务器暂时过载或维护。
- 504 Gateway Timeout：网关超时，上游服务器未及时响应。
- 505 HTTP Version Not Supported：HTTP 版本不支持，服务器不支持请求的 HTTP 版本。


## 秒杀系统的设计


针对秒杀系统的特点，我们可以采取如下的措施来提升系统的性能。
![[Pasted image 20230823170809.png]]
### 总体思路

**（1）异步解耦**

将整体流程进行拆解，核心流程通过队列方式进行控制。

**（2）限流防刷**

控制网站整体流量，提高请求的门槛，避免系统资源耗尽。

**（3）资源控制**

将整体流程中的资源调度进行控制，扬长避短。


如果在秒杀活动开始时，并发量太高时，我们可以将用户的请求放入队列中进行处理，并为用户弹出排队页面。
![[Pasted image 20230823171038.png]]

### 资源静态化：

秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，所以页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入**cdn服务器**的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。

### 横向扩容
![[Pasted image 20230823172047.png]]
**Nginx**大家想必都不陌生了吧，这玩意是**高性能的web服务器**，并发也随便顶几万不是梦，但是我们的**Tomcat**只能顶几百的并发呀，那简单呀**负载均衡**嘛，一台服务几百，那就多搞点，在秒杀的时候多租点**流量机**。

Tip：据我所知国内某大厂就是在去年春节活动期间租光了亚洲所有的服务器，小公司也很喜欢在双十一期间买流量机来顶住压力。
### 秒杀按钮

大部分用户怕错过`秒杀时间点`，一般会提前进入活动页面。此时看到的`秒杀按钮`是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。

但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。

从前面得知，该活动页面是静态的。那么我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？

没错，使用js文件控制。

为了性能考虑，一般会将css、js和图片等静态资源文件提前缓存到CDN上，让用户能够就近访问秒杀页面。

看到这里，有些聪明的小伙伴，可能会问：CDN上的js文件是如何更新的？

秒杀开始之前，js标志为false，还有另外一个随机参数。

![](https://ask.qcloudimg.com/http-save/5604447/4c72b26254457198373314943096f8a4.jpeg)

当秒杀开始的时候系统会生成一个新的js文件，此时标志为true，并且随机参数生成一个新值，然后同步给CDN。由于有了这个随机参数，CDN不会缓存数据，每次都能从CDN中获取最新的js代码。

此外，前端还可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。

### mq异步处理
#### 消息丢失问题

秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。

那么，如何防止消息丢失呢？

答：加一张消息发送表。
![[Pasted image 20230823174211.png]]
在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。

如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。

这时候，要如何处理呢？

答：使用job，增加重试机制。
用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。
  
上述提到的 "job" 指的是一个定时任务（也称为定时作业或定时调度），它是一个在预定时间间隔或特定时间点执行的程序或处理过程。在这种情况下，您可以使用一个定时任务来定期检查消息发送表中状态为待处理的消息，并尝试重新发送消息，以处理由于发送失败而导致的消息丢失问题。

在 Java 生态系统中，您可以使用各种库和框架来创建定时任务。以下是一些常见的选择：

1. **Quartz：** Quartz 是一个功能强大的定时任务调度框架，可以用于创建复杂的定时任务。它支持灵活的任务调度和重试机制，非常适合处理您描述的情况。您可以定义一个定时任务，让它每隔一段时间查询待处理的消息，并重新发送。

#### 重复消费问题

本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。

那么，如何解决重复消息问题呢？

答：加一张消息处理表。
![[Pasted image 20230823174507.png]]
#### 垃圾消息问题

这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。

那么，如何解决这个问题呢？

![](https://ask.qcloudimg.com/http-save/5604447/8c356c99fdbe30ca6324cc5fbf9bf1e5.jpeg)

每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。

这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。

#### 延迟消费问题

通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。

那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？

我们首先想到的可能是job，因为它比较简单。

但job有个问题，需要每隔一段时间处理一次，实时性不太好。

还有更好的方案？

答：使用延迟队列。

我们都知道rocketmq，自带了延迟队列的功能。

![](https://ask.qcloudimg.com/http-save/5604447/607d395be8f05a185ed3513ccccd3176.jpeg)

下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

还有个关键点，用户完成支付之后，会修改订单状态为已支付。


### 如何限流？
1. 基于nginx限流
2. 基于redis限流

#### 对同一用户限流

为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。
限制同一个用户id，比如每分钟只能请求5次接口。

#### 对同一ip限流

有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。

这时需要加同一ip限流功能。


#### 提高业务门槛

上面说的加验证码虽然可以限制非法用户请求，但是有些影响用户体验。用户点击秒杀按钮前，还要先输入验证码，流程显得有点繁琐，秒杀功能的流程不是应该越简单越好吗？

其实，有时候达到某个目的，不一定非要通过技术手段，通过业务手段也一样。

12306刚开始的时候，全国人民都在同一时刻抢火车票，由于并发量太大，系统经常挂。后来，重构优化之后，将购买周期放长了，可以提前20天购买火车票，并且可以在9点、10、11点、12点等整点购买火车票。调整业务之后（当然技术也有很多调整），将之前集中的请求，分散开了，一下子降低了用户并发量。

回到这里，我们通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。



  
## MySQL 带in的查询语句如何优化
1. **使用索引：** 确保相关的列上存在索引，这将大大提高`IN`子句的性能。当列上存在索引时，数据库可以更快地定位匹配的值。
    
2. **适当选择字段类型：** 选择合适的数据类型可以提升性能。例如，使用整数代替字符串作为`IN`子句中的值，因为整数比字符串更快地进行比较。
    
3. **限制`IN`中的项数：** 当`IN`子句中的项数很大时，性能可能下降。尽量将项数限制在合理范围内。
    
4. **使用`EXISTS`代替`IN`：** 在某些情况下，将`IN`子句替换为`EXISTS`子查询可以提高性能，因为`EXISTS`只需要找到一个匹配项就可以停止搜索，而不需要检查所有的值。
    
5. **使用临时表：** 对于大型的`IN`子句，你可以考虑创建一个临时表，将要查询的值插入临时表中，然后通过连接来执行查询。这样可以减少`IN`子句中的项数，提高查询性能。
    
6. **使用JOIN：** 在某些情况下，使用`JOIN`操作可以代替`IN`子句，这可能会提供更好的性能。通过将两个表连接起来，可以更有效地获取所需的数据。
    
7. **定期优化表：** 执行定期的表优化操作，包括更新统计信息和重新建立索引，以确保数据库的性能保持良好。
    
8. **考虑数据库设计：** 在数据库设计阶段就考虑查询的优化，包括表结构、索引和关联等方面。
    
9. **使用缓存：** 如果某些查询的结果不经常变化，可以考虑使用缓存技术，如Memcached或Redis，以避免频繁地执行相同的查询。


